use crate::nl::core::object::*;
use crate::nl::interpreter::*;

/// Registers all builtin flow control forms.
///
pub fn register_builtin_flow_forms(scope: &mut Scope) {
    scope
        .register_special_form("if", flow_if)
        .register_special_form("while", flow_while)
        .register_special_form("break", flow_break)
        .register_special_form("do", flow_do)
        .register_special_form("let", flow_let);
}

/// `if` special form.
///
/// `(if cond then)`
/// `(if cond then else)`
///
fn flow_if(scope: &mut Scope, args: &[Object]) -> Result<Object, Error> {
    if args.len() < 2 || args.len() > 3 {
        return Error::err(&format!(
            "`if` receives 2 or 3 arguments, got {} instead.",
            args.len()
        ));
    }

    match evaluate(scope, &args[0]) {
        Ok(v) => {
            if !v.is_bool() {
                return Error::err(&format!(
                    "Expected an Bool, got a '{}' from {}",
                    v.kind_string(),
                    v
                ));
            }

            if args.len() == 2 {
                if v.get_bool() {
                    match evaluate(scope.enter(Mode::Evaluation), &args[1]) {
                        Err(e) => return Err(e),
                        _ => {}
                    };
                    scope.leave();
                }

                return Ok(Object::nil());
            }

            if args.len() == 3 {
                return if v.get_bool() {
                    let r = evaluate(scope.enter(Mode::Evaluation), &args[1]);
                    scope.leave();

                    r
                } else {
                    let r = evaluate(scope.enter(Mode::Evaluation), &args[2]);
                    scope.leave();

                    r
                };
            }

            unreachable!()
        }
        Err(v) => Err(v),
    }
}

/// `while` special form.
///
/// `(while cond body...)`
///
fn flow_while(scope: &mut Scope, args: &[Object]) -> Result<Object, Error> {
    if args.len() < 2 {
        return Error::err(&format!(
            "'while' requires at least 2 arguments, got {} instead.",
            args.len()
        ));
    }

    let cond = &args[0];

    loop {
        match evaluate(scope, cond) {
            Ok(o) => {
                if !o.is_bool() {
                    return Error::err(&format!(
                        "'while' requires a Bool, get a '{}' from {}",
                        o.kind_string(),
                        cond
                    ));
                }

                if !o.get_bool() {
                    break;
                }

                scope.enter_loop(Mode::Evaluation);

                for expr in args.iter().skip(1) {
                    match evaluate(scope, expr) {
                        Err(e) => return Err(e),
                        Ok(_) => {}
                    }
                }

                if scope.is_loop_broken() {
                    scope.leave();
                    break;
                }

                scope.leave();
            }
            Err(v) => return Err(v),
        }
    }

    Ok(Object::nil())
}

/// `break` special form.
///
/// `(break)`
///
fn flow_break(scope: &mut Scope, args: &[Object]) -> Result<Object, Error> {
    if args.len() != 0 {
        return Error::err(&format!(
            "'break' doesn't take any argument, got {} instead.",
            args.len()
        ));
    }

    if !scope.is_in_loop() {
        return Error::err("'break' can only be used in loops.");
    }

    scope.break_loop();

    Ok(Object::nil())
}

/// `do` special form.
///
/// `(do body...)`
///
fn flow_do(scope: &mut Scope, args: &[Object]) -> Result<Object, Error> {
    scope.enter(Mode::Evaluation);

    let mut result = Object::nil();

    for expr in args {
        match evaluate(scope, expr) {
            Ok(v) => result = v,
            Err(v) => return Err(v),
        }
    }

    scope.leave();
    Ok(result)
}

/// `let` special form.
///
/// `(let (var0 expr0 var1 expr1 ...) body...)`
///
fn flow_let(scope: &mut Scope, args: &[Object]) -> Result<Object, Error> {
    if args.len() < 2 {
        return Error::err(&format!(
            "'let' requires at least 2 arguments, got {} instead.",
            args.len()
        ));
    }

    scope.enter(Mode::Evaluation);

    match flow_let_define_bindings(scope, &args[0]) {
        Some(err) => return Err(err),
        None => {}
    }

    let mut result = Object::nil();

    for expr in args.iter().skip(1) {
        match evaluate(scope, expr) {
            Ok(v) => result = v,
            Err(v) => return Err(v),
        }
    }

    scope.leave();
    Ok(result)
}

/// Defines the bindings generated by the `let` special form.
///
fn flow_let_define_bindings(scope: &mut Scope, list: &Object) -> Option<Error> {
    if !list.is_list() {
        return Some(Error::new(&format!(
            "invalid 'let' syntax at {}.\nSyntax : (let (v0 expr0 v1 expr1 ...) body...)",
            list
        )));
    }

    let vec = list.get_list();

    if vec.len() % 2 != 0 {
        return Some(Error::new(&format!(
            "invalid 'let' syntax at {}.\nSyntax : (let (v0 expr0 v1 expr1 ...) body...)",
            list
        )));
    }

    let mut i = 0;
    while i < vec.len() {
        let name = &vec[i];
        let expr = &vec[i + 1];

        if !name.is_symbol() {
            return Some(Error::new(&format!(
                "invalid 'let' syntax at {}.\nA variable name must be a Symbol.",
                name
            )));
        }

        let binding = Binding::DynamicVariable(match evaluate(scope, expr) {
            Ok(v) => v,
            Err(v) => return Some(v),
        });

        scope.insert(name.get_symbol().clone(), binding);

        i += 2;
    }

    None
}
